---
layout: post
title:  "从零开始gorm(三)"
date:   2019-06-03 13:20:42
categories: ORM Go
tags: ORM Go
---

* content
{:toc}



## 增删查改

### 新增

#### 创建记录 

一般的,我们使用`Create`来创建新的记录,当我们需要手动指定一条数据的主键时,在插入数据前可以使用`NewRecord`判断
库中是否已经存在主键值相同的数据;插入数据后,我们也可以使用`NewRecord`来检查数据是否确实插入到了库中

```go

user := User{Name: "test", Age:18, Brithday: time.Now()}


// 会检查数据库内是否有主键值为传入的值的数据存在,如果存在说明主键重复,会返回false
db.NewRecord(user) // ==> user内未填写主键字段的值,返回true

// Create往库内插入一条数据
db.Create(&user)

// 再次调用newRecord,此时user的主键字段被填充值,再调用newRecord会返回false,说明数据已经插入到库中
db.NewRecord(user) // ==> user数据已经被插入到库中,此时返回false

```

#### 默认值


可以通过声明字段的`default`来修改字段的默认值,默认值为`tag`的内容;
当我们执行插入时,如果未对字段进行赋值或是给字段赋予了零值的情况下, 
`gorm`在生成插入SQL时会自动过滤掉这些未经过设置的字段,数据被成功插入到数据库后,`gorm`会从数据库中将之前未设置的
字段的值加载回字段中

```go

type Animal struct {
	ID      int64
	Name    string      `gorm:"default:galeone"`
	Age     int64
}


var animal = Animal{Agent:99,}

db.Create(&animal)
// INSERT INTO animals (age) values(99);
//插入成功后,会从数据库加载字段值
// animal.Name ==> "galeone" 

```

**所有的字段都有一个类型零值,比如0, "",false或是其它的零值,如果字段设置了默认值,此时给字段赋予类型零值,
进行插入操作时,将会使用设置的默认值替代零值;
如果设置了默认值但是确实需要给该记录的字段赋予类型零值,可以将字段设置为指针类型或是scanner/valuer类型**

```go

// 使用指针类型
type User struct {
	gorm.Model
	Name        string
	Age         *int        `gorm:"default:18"`
}


// 使用 scanner/valuer
type User struct {
	gorm.Model
	Name            string
	Age             sql.NullInt64   `gorm:"default:18"`
}

```

#### 在hook中设置字段的值

`gorm`提供了`BeforeCreate`hook,比如我们可以通过使用`scope.SetColumn`来设置字段值

```go

func (user *User) BeforeCreate(scope *gorm.Scope) error {
	scope.SetColumn("ID", uuid.New())
	return nil
}
```


#### 扩展创建选项

`gorm`提供了`Set`方法用于扩展SQL选项

```go

db.Set("gorm:insert_option", "ON CONFLICT").Create(&User)
// INSERT INTO users (name, age) VALUES ("jack", 18) ON CONFLICT;

```

#### FirstOrCreate

先尝试获取符合查询条件的一条记录,如果没查询到符合条件的记录,使用给定的条件创建一条新的记录
***传入的条件只能是`struct`或是`Map`***

```go

// 数据库未找到记录的情况
db.FirstOrCreate(&user, user{Name: "admin"})
// INSERT INTO users (name) Values ("admin")
// 返回值为: user{Id: 1, Name: "admin"}

// 数据库查询到记录的情况
db.Where(User{Name: "admin"}).FirstOrCreate(&user)
//返回值为: user{Id:1, Name: "admin" Age: 20}

```

***当我们需要为新插入到库中的记录初始化其它没有作为查询字段的值时,可以使用`Attrs`***

```go

// 未查询到的情况
db.Where(user{Name: "admin"}).Attrs(user{Age: 20}).FirstOrCreate(&user)
// SELECT * FROM users WHERE name = 'admin';
// INSERT INTO "users" (name, age) VALUES ("admin", 20);
// 返回值为: user{Id: 1, Name: "admin", Age: 20}



// 再次执行
db.Where(user{Name: "admin"}).Attrs(map[string]interface{}{"age": 30}).FirstOrCreate(&user)
// SELECT * FROM users WHERE name = 'admin';
// 返回值为: user{Id: 1, Name: "admin", Age: 20}

```

***当我们需要为新插入到库中的记录初始化其它没有作为查询字段的值,或是更新查询出来的记录的某些字段时,可以使用
`Assign`***

```go

// 未查询到记录的情况
db.Where(User{Name: "admin"}).Assign(User{Age: 20}).FirstOrCreate(&user)
// SELECT * FROM users WHERE name = 'admin';
// INSERT INTO "users" (name, age) VALUES ("admin", 20);
// 返回的值为: user{Id: 1, Name: "admin", Age: 20}

// 查询到记录的情况
db.Where(User{Name: "admin"}).Assign(map[string]interface{}{"age": 30}).FirstOrCreate(&user)
// SELECT * FROM users WHERE name = 'admin';
// UPDATE users SET age=30 WHERE id = 1;
// 返回的值: user{Id: 1, Name: "admin", Age: 30}

```

***`Attrs`和`Assign`的相同点是都能在未查询到记录的情况下用来为非查询条件的字段填充值,
不同点是`Assign`还能在查询到记录的情况下用来更新非查询条件字段的值***


### 查询

#### query

`gorm`提供了多种用于查询的接口

```go

// 使用主键排序,并获取第一条记录
db.Frist(&user)
// SELECT * FROM users ORDER BY id LIMIT 1;

// 当主键为整数型时,使用主键值查询某条指定的记录
db.Frist(&user, 10)
// SELECT * FROM users WHERE id = 10;

//返回一条数据
db.Take(&user)
// SELECT * FROM users LIMIT 1;

// 使用 primary key 排序,获取最后一条记录
db.Last(&user)
// SELECT * FROM users ORDER BY id DESC LIMIT 1;

// 获取所有数据
db.Find(&User)
// SELECT * FROM users;

```

#### Where

```go

var users []user

// 获取第一个匹配的记录
db.Where("name = ?", "admin").Frist(&user)
// SELECT * FROM users WHERE name = "admin" limit 1;

// 获取所有匹配的记录
db.Where("name = ?", "admin").Find(&user)
// SELECT * FROM users WHERE name = "admin";

// 不等于
db.Where("name <> ?", "admin").Find(&users)
// SELECT * FROM user WHERE name != "admin";

// IN
db.Where("name in (?)", []string{"jinzhu", "jinzhu 2"}).Find(&users)

// LIKE
db.Where("name LIKE ?", "%jin%").Find(&users)

// AND
db.Where("name = ? AND age >= ?", "jinzhu", "22").Find(&users)

// Time
db.Where("updated_at > ?", lastWeek).Find(&users) 

// BETWEEN
db.Where("created_at BETWEEN ? AND ?", lastWeek, today).Find(&users)


```

使用`Where`语句的时候,还可以直接传入`Map`或是`struct`, `gorm`会自动解析`Map`的键值对或是`struct`的字段值并使用`AND`连接条件

```go

// struct
db.Where(&user{Name:"admin", Age: 18}).Frist(&user)
// SELECT * FROM users WHERE name = "admin" AND age = 18 limit 1;


var users []user

//Map
db.Where(map[string]interface{}{"name": "admin", "age": 18}).Find(&users)
// SELECT * FROM users WHERE name = "admin" AND age = 18;

```

***当通过`struct`进行查询时,`gorm`将会只会使用结构体中非零值字段的值,如果字段的值恰好为字段的类型零值,这个字段将会被排除出查询条件***

```go

type user struct {
	gorm.Model
	Name        string
	Age         int        `gorm:"default:18"`
}

db.Where(&user{Name: "admin", Age: 0}).Find([]&user)
// SELECT * FROM users WHERE name = "admin";


var admins []admin
// 可以使用指针类型来规避该问题
type admin struct {
	gorm.Model
    	Name        string
    	Age         *int        `gorm:"default:18"`
}

age := 0

db.Where(&admin{Name:"admin", Age: &age}).Find(&admins)
// SELECT * FROM admins WHERE name = "admin" AND age = 0;

```

***`Where`中还能使用slice作为查询条件,只有当查询条件使用的字段为主键时才能使用slice作为查询条件***

```go

var users []user

// 使用slice作为查询条件
db.Where([]int64{20, 21, 24}).Find(&users)
// SELECT * FROM users WHERE id IN (20, 21, 24);

```

#### Not

`Not`的使用方法类似于`Where`

```go

var users []user

// 不等于
db.Not("name", "test").Frist(&user)
// SELECT * FROM users WHERE name <> "test" LIMIT 1;

db.Not("name = ?", "test").Frist(&user)
// SELECT * FROM users WHERE NOT (name == "test") LIMIT 1'

// not In
db.Not("name", []string{"test", "admin"}).Find(&users)
// SELECT * FROM users WHERE name NOT IN ("test", "admin");

// 传入slice,默认查询条件为主键
db.Not([]int64{1, 2, 3}).Find(&users)
// SELECT * FROM users WHERE id NOT IN (1, 2, 3);

// 传入空的slice
db.Not([]int64{}).Find(&users)
// SELECT * FROM users;

// 使用结构体
db.Not(user{Name: "admin"}).Frist(&user)
// SELECT * FROM users WHERE name <> "admin" LIMIT 1;

```

#### Or

```go

var users []user

db.Where("role = ?", "admin").Or("role = ?", "super_admin").Find(&users)
// SELECT * FROM users WHERE role == "admin" OR role == "super_admin";


// 传入struct
db.Where("name = 'admin'").Or(user{Name: "test"}).Find(&users)
// SELECT * From users WHERE name = "admin" OR name = "test";


// 传入Map
db.Where("name = 'admin'").Or(map[string]interface{}{"name": "test"}).Find(&users)
// SELECT * From users WHERE name = "admin" OR name = "test";

```

#### Inline Condition

我们还可以直接向`Find`或是`First`传递查询条件,需要注意的是当直接往`Find`或是`First`中传递查询条件时,无法和`Where`等查询方式同时使用

```go

var users []user

db.First(&user, "id = ?", "string_primary_key")
//// SELECT * FROM users WHERE id = 'string_primary_key' LIMIT 1;

// Plain SQL
db.Find(&user, "name = ?", "jinzhu")
//// SELECT * FROM users WHERE name = "jinzhu";

db.Find(&users), "name <> ? AND age > ?", "jinzhu", 20)
//// SELECT * FROM users WHERE name <> "jinzhu" AND age > 20;

// Struct
db.Find(&users, User{Age: 20})
//// SELECT * FROM users WHERE age = 20;

// Map
db.Find(&users, map[string]interface{}{"age": 20})
//// SELECT * FROM users WHERE age = 20;

```

#### FirstOrInit

同`FirstOrCreate`类似,`FirstOrInit`通过给定的条件查询记录,如果查询到记录则返回查询到的记录,如果没有查询到记录则返回一个用查询条件初始化后的结构体

***同样的,查询条件只能是`struct`或是`Map`***

```go

// 未查询到的情况
db.FirstOrInit(&user, user{Name: "admin"})
// 返回值为: user{Id: 1, Name:"admin"}

// 查询到的情况
db.FirstOrInit(&user, map[string]interface{}{"name": "admin"})
db.Where(user{Name: "admin"}).FirstOrInit(&user)
// 返回值为: user{Id: 1, Name: "admin"}


```

***同样的`FirstOrInit`可以使用`Attrs`为非查询条件的字段填充值***

```go

// 为查询到的情况
db.Where(user{Name: "admin"}).Attrs(user{Age: 20}).FirstOrInit(&user)
// SELECT * FROM users WHERE name = "admin";
// 返回值为: user{Name: "admin", Age: 20}

db.Where(user{Name: "admin"}).Attrs("age", 40}).FirstOrInit(&user)
// SELECT * FROM users WHERE name = "admin";
// 返回值为: user{Name: "admin", Age: 40}

// 查询到记录的情况
db.Where(user{Name: "admin"}).Attrs(map[string]interface{}{"age": 30}).FirstOrInit(&user)
// SELECT * FROM users WHERE name = "admin"
// 返回值: user{Id: 1, Name: "admin", Age: 20}

```

***`FirstOrInit`也可以使用`Assign`为非查询条件的字段填充或是修改值***

```go

// 未查找到的情况
db.Where(user{Name: "admin"}).Assign(user{Age: 20}).FirstOrInit(&user)
// SELECT * FROM users WHERE name = "admin"
// 返回值: user{Name: "admin", Age: 20}


// 查找到的情况
db.Where(user{Name: "admin"}).Assign(user{Age: 30}).FirstOrInit(&user)
// SELECT * FROM users WHERE name = "admin"
// 返回值: user{Id: 1 Name: "admin", Age: 30}


```

***`Attrs`和`Assign`的相同点是都能在未查询到记录的情况下用来为非查询条件的字段填充值,
不同点是`Assign`还能在查询到记录的情况下用来修改非查询条件字段的值***


### 高级查询

#### 子查询


